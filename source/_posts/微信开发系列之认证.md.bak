---
title: 微信开发系列之认证
date: 2016-08-08 14:36:43
tags: 微信开发
categories: 微信开发
---

### 概述
最近在做分享领卷，需要微信认证后获取微信用户的个人数据，其中也趟了不过微信的坑。实现效果跟饿了么相同，即微信打开链接首先认证并获取微信用户的个人信息，领卷成功后再次在微信中点击链接显示已经领取过的优惠卷信息。现总结微信认证的实现过程。

<!--more-->

### 微信开发者官网
[微信开发者文档](https://mp.weixin.qq.com/wiki/home/index.html)

### 开发流程

#### 生成认证的URL
<pre><code>
/**
     * 获取微信授权链接
     * @param string $redirect_uri
     * @param string $state
     * @return string
     */
    public static function get_authorize_url($redirect_uri = '', $state = '')
    {
        $redirect_uri = urlencode($redirect_uri);
        $authorize_url = 'https://open.weixin.qq.com/connect/oauth2/authorize';
        $url = $authorize_url . '?appid=' . Config::get('config.weixin_appId') . '&redirect_uri=' . $redirect_uri
            . '&response_type=code&scope=snsapi_userinfo&state=' . $state . '#wechat_redirect';
        Log::info("get_authorize_url", array('authorize_url' => $url));
        return $url;
    }
</code></pre>

#### 通过code换取网页授权access_token
用户点击同意授权后，页面跳转到redirect_uri 提供的页面，并且携带code 码，实现代码：
<pre><code>
/**
     * 获取授权token
     * @param string $code
     * @return string
     */
    public static function get_authorize_token($code = '')
    {
        $tokenData = '';
        do {
            $token_url = "https://api.weixin.qq.com/sns/oauth2/access_token?appid=" . Config::get('config.weixin_appId') .
                "&secret=" . Config::get('config.weixin_appSecret') .
                "&code={$code}&grant_type=authorization_code";
            $token_data = json_decode(Helps::curlHttpGet($token_url), true);
            Log::info("get_authorize_token", array("token_data>>>>>>>>>>>"=>$token_data));
            if (!empty($token_data['errcode']))
                break;
            $tokenData = json_encode($token_data);
            Cache::put($token_data['openid'] . 'token', $token_data['access_token'], $token_data['expires_in'] / 60);
            Cache::put($token_data['openid'] . 'refresh', $token_data['refresh_token'], Config::get('config.cacheTime'));
            Log::info("get_authorize_token", array('refresh>>>>>>' => Cache::get($token_data['openid'] . 'refresh'),
            'token'=>Cache::get($token_data['openid'] . 'token'),'code'=>Cache::get($code)));
        } while (false);
        Log::info("get_authorize_token", array('authorize_token' => json_decode($tokenData, true)));
        return $tokenData;
    }
</pre></code>

#### 刷新access_token（如果需要）
由于access_token拥有较短的有效期，当access_token超时后，可以使用refresh_token进行刷新，refresh_token拥有较长的有效期（7天、30天、60天、90天），当refresh_token失效的后，需要用户重新授权。
<pre><code>
/**
     * 刷新token
     */
    public static function refresh_token($openid)
    {
        $response = array("code" => 0, 'msg' => 'ok', 'result' => array());
        do {
            if (!Cache::has($openid . 'refresh')) {
                $response = array("code" => 110017, 'msg' => 'openid 失效,请重新认证', 'result' => array());
                break;
            }
            $refresh_token = Cache::get($openid . 'refresh');
            $url = 'https://api.weixin.qq.com/sns/oauth2/refresh_token?appid=' . Config::get('config.weixin_appId') .
                '&grant_type=refresh_token&refresh_token=' . $refresh_token;
            $token_data = json_decode(Helps::curlHttpGet($url), true);
            if (!empty($token_data['errcode'])) {
                $response = array("code" => 110018, 'msg' => 'invalid code', 'result' => array());
                break;
            }
            Cache::put($token_data['openid'] . 'token', $token_data['access_token'], $token_data['expires_in'] / 60);
        } while (false);
        return $response;
    }
</pre></code>

#### 拉取用户信息
如果网页授权作用域为snsapi_userinfo，则此时开发者可以通过access_token和openid拉取用户信息了。
<pre><code>
 /**
     * 获取用户信息
     * @param $lang
     * @param $token
     * @param $openid
     * @return jsonString
     */
    public static function userInfoBytoken($token, $openid, $lang = 'zh_CN')
    {
        $userInfo = '';
        do {
            if (empty($token)) {
                break;
            }
            $userInfo_url = 'https://api.weixin.qq.com/sns/userinfo?access_token=' . $token
                . '&openid=' . $openid . '&lang=' . $lang;
            Log::info("userInfoBytoken", array('url>>>>>>>>>' => $userInfo_url));
            $userData = json_decode(Helps::curlHttpGet($userInfo_url), true);
            if (!empty($userData['errcode']))
                break;
            $userInfo = $userData;
        } while (false);
        Log::info("userInfoBytoken", array('userInfo' => $userInfo));
        return $userInfo;
    }
</pre></code>

#### 判断是否是微信打开
<pre><code>
/**
     * 判断是否是微信打开
     * @return bool
     */
    public static function isWechat()
    {
        $user_agent = $_SERVER['HTTP_USER_AGENT'];
        if (strpos($user_agent, 'MicroMessenger') === false) {
            return false;
        }
        return true;
    }
</pre></code>

#### 重大的坑
以snsapi_base为scope发起的网页授权，是用来获取进入页面的用户的openid的，并且是静默授权并自动跳转到回调页的。用户感知的就是直接进入了回调页（往往是业务页面）。如果整套逻辑在后台做，每次用户请求后台都需要获取用户的openid,
但是使用snsapi_base为scope发起的网页授权 会把以snsapi_userinfo为scope发起的网页授权 给替换掉，当求用户信息的时候，会报错。